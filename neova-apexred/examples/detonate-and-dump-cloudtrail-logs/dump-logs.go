package main

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/DataDog/datadog-api-client-go/api/v2/datadog"
	"github.com/datadog/stratus-red-team/v2/pkg/stratus"
	_ "github.com/datadog/stratus-red-team/v2/pkg/stratus/loader" // Note: This import is needed
	stratusrunner "github.com/datadog/stratus-red-team/v2/pkg/stratus/runner"
	"os"
	"strconv"
	"time"
)

// Detonates a TTP using Stratus Red Team
func detonateTTP(stratusRedTeamTTP string) (*stratusrunner.Runner, error) {
	ttp := stratus.GetRegistry().GetAttackTechniqueByName(stratusRedTeamTTP)
	if ttp == nil {
		return nil, errors.New("unknown TTP: " + stratusRedTeamTTP)
	}
	stratusRunner := stratusrunner.NewRunner(ttp, stratusrunner.StratusRunnerNoForce)

	fmt.Println("Detonating '" + stratusRedTeamTTP + "' with Stratus Red Team")

	_, err := stratusRunner.WarmUp()
	if err != nil {
		return nil, err
	}
	err = stratusRunner.Detonate()
	if err != nil {
		return nil, err
	}
	return &stratusRunner, nil
}

// Uses the Datadog API to retrieve the logs generated by a specific Stratus Red Team detonation
func findLogs(detonationUuid string) (*[]map[string]interface{}, error) {
	ctx := context.WithValue(context.Background(), datadog.ContextAPIKeys, map[string]datadog.APIKey{
		"apiKeyAuth": {Key: os.Getenv("DD_API_KEY")},
		"appKeyAuth": {Key: os.Getenv("DD_APP_KEY")},
	})
	cfg := datadog.NewConfiguration()
	apiClient := datadog.NewAPIClient(cfg)

	query := fmt.Sprintf(
		"@http.useragent:stratus-red-team_%s OR @userAgent:stratus-red-team_%s",
		detonationUuid,
		detonationUuid,
	)
	queryRequest := datadog.LogsListRequest{
		Filter: &datadog.LogsQueryFilter{
			Query: datadog.PtrString(query),
			From:  datadog.PtrString(strconv.FormatInt(time.Now().Add(-1*time.Hour).UnixMilli(), 10)),
			To:    datadog.PtrString(strconv.FormatInt(time.Now().UnixMilli(), 10)),
		},
		Sort: datadog.LOGSSORT_TIMESTAMP_ASCENDING.Ptr(),
		Page: &datadog.LogsListRequestPage{
			Limit: datadog.PtrInt32(1000),
		},
	}
	result, _, err := apiClient.LogsApi.ListLogs(ctx, *datadog.NewListLogsOptionalParameters().WithBody(queryRequest))
	if err != nil {
		return nil, err
	}

	logs := result.Data
	logEntries := []map[string]interface{}{}
	if len(logs) == 0 {
		return &logEntries, nil
	}

	for i := range logs {
		logEntries = append(logEntries, logs[i].Attributes.Attributes)
	}
	return &logEntries, nil
}

func dumpLogs(logs *[]map[string]interface{}, filename string) {
	fp, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)
	if err != nil {
		fmt.Println("unable to open file")
		return
	}
	defer fp.Close()

	btes, _ := json.MarshalIndent(logs, " ", " ")
	fp.Write(btes)
}

func main() {
	if len(os.Args) != 3 {
		fmt.Println("Usage: go run <filename>.go <stratus-red-team-ttp-name> <logs-output-file>")
		os.Exit(1)
	}
	runner, err := detonateTTP(os.Args[1])
	defer runner.CleanUp()
	if err != nil {
		fmt.Println(err.Error())
		return
	}

	fmt.Println("Execution UID: " + runner.GetUniqueExecutionId())
	start := time.Now()
	const timeout = 15 * time.Minute
	const interval = 15 * time.Second
	found := false
	for !found && !time.Now().After(start.Add(timeout)) {
		time.Sleep(interval)

		fmt.Println("Searching for logs in Datadog")
		logs, err := findLogs(runner.GetUniqueExecutionId())
		if err != nil {
			fmt.Println(err.Error())
			os.Exit(1)
		}
		if numLogs := len(*logs); numLogs > 0 {
			fmt.Println("Found " + strconv.Itoa(numLogs) + " matching logs!")
			dumpLogs(logs, os.Args[2])
			found = true
		} else {
			fmt.Println("No logs found. Sleeping for " + interval.String())
		}
	}

	if !found {
		fmt.Println("Timed out")
		os.Exit(1)
	}
}
